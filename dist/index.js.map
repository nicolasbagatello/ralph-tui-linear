{
  "version": 3,
  "sources": ["../src/index.ts", "../src/client.ts"],
  "sourcesContent": [
    "/**\n * ABOUTME: Linear tracker plugin for ralph-tui.\n * Integrates with Linear API for real-time task tracking with two-way sync.\n * Supports hierarchical display (Project → Epic → Task), task claiming,\n * and conflict resolution.\n *\n * Install: npm install -g ralph-tui-linear\n * Setup: ralph-tui-linear-setup\n */\n\nimport { readFileSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { LinearApiClient, type LinearIssue, type LinearStateType, type LinearState } from './client.js';\nimport type {\n  TrackerPlugin,\n  TrackerPluginMeta,\n  TrackerPluginFactory,\n  TrackerTask,\n  TrackerTaskStatus,\n  TaskPriority,\n  TaskFilter,\n  TaskCompletionResult,\n  SyncResult,\n  SetupQuestion,\n  ConflictInfo,\n} from './types.js';\n\n// Get __dirname equivalent for ESM\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\n// =============================================================================\n// Helper Functions\n// =============================================================================\n\n/**\n * Map Linear state type to TrackerTaskStatus\n */\nfunction mapStateToStatus(stateType: LinearStateType): TrackerTaskStatus {\n  switch (stateType) {\n    case 'backlog':\n    case 'unstarted':\n      return 'open';\n    case 'started':\n      return 'in_progress';\n    case 'completed':\n      return 'completed';\n    case 'canceled':\n      return 'cancelled';\n    default:\n      return 'open';\n  }\n}\n\n/**\n * Map TrackerTaskStatus to Linear state type\n */\nfunction mapStatusToStateType(status: TrackerTaskStatus): LinearStateType {\n  switch (status) {\n    case 'open':\n      return 'unstarted';\n    case 'in_progress':\n      return 'started';\n    case 'completed':\n      return 'completed';\n    case 'cancelled':\n      return 'canceled';\n    case 'blocked':\n      return 'started';\n    default:\n      return 'unstarted';\n  }\n}\n\n/**\n * Map Linear priority to TaskPriority\n */\nfunction mapPriority(linearPriority: number): TaskPriority {\n  if (linearPriority === 0) return 2;\n  return Math.min(4, Math.max(0, linearPriority - 1)) as TaskPriority;\n}\n\n/**\n * Convert Linear issue to TrackerTask\n */\nfunction issueToTask(issue: LinearIssue): TrackerTask {\n  const labels = issue.labels.nodes.map((l) => l.name);\n  const isEpic = labels.some((l) => l.toLowerCase() === 'epic');\n\n  return {\n    id: issue.id,\n    title: `${issue.identifier}: ${issue.title}`,\n    status: mapStateToStatus(issue.state.type),\n    priority: mapPriority(issue.priority),\n    description: issue.description,\n    labels,\n    type: isEpic ? 'epic' : 'task',\n    parentId: issue.parent?.id,\n    assignee: issue.assignee?.email,\n    createdAt: issue.createdAt,\n    updatedAt: issue.updatedAt,\n    metadata: {\n      identifier: issue.identifier,\n      stateId: issue.state.id,\n      stateName: issue.state.name,\n      projectId: issue.project?.id,\n      projectName: issue.project?.name,\n      childCount: issue.children?.nodes.length ?? 0,\n      completedChildCount: issue.children?.nodes.filter(\n        (c) => c.state.type === 'completed' || c.state.type === 'canceled'\n      ).length ?? 0,\n    },\n  };\n}\n\n/**\n * Filter tasks by criteria\n */\nfunction filterTasks(tasks: TrackerTask[], filter?: TaskFilter): TrackerTask[] {\n  if (!filter) return tasks;\n\n  let result = tasks;\n\n  if (filter.status) {\n    const statuses = Array.isArray(filter.status) ? filter.status : [filter.status];\n    result = result.filter((t) => statuses.includes(t.status));\n  }\n\n  if (filter.labels && filter.labels.length > 0) {\n    result = result.filter((t) =>\n      filter.labels!.every((label) => t.labels?.includes(label))\n    );\n  }\n\n  if (filter.priority !== undefined) {\n    const priorities = Array.isArray(filter.priority) ? filter.priority : [filter.priority];\n    result = result.filter((t) => priorities.includes(t.priority));\n  }\n\n  if (filter.parentId) {\n    result = result.filter((t) => t.parentId === filter.parentId);\n  }\n\n  if (filter.assignee) {\n    result = result.filter((t) => t.assignee === filter.assignee);\n  }\n\n  if (filter.type) {\n    const types = Array.isArray(filter.type) ? filter.type : [filter.type];\n    result = result.filter((t) => t.type && types.includes(t.type));\n  }\n\n  if (filter.excludeIds && filter.excludeIds.length > 0) {\n    const excludeSet = new Set(filter.excludeIds);\n    result = result.filter((t) => !excludeSet.has(t.id));\n  }\n\n  if (filter.ready) {\n    result = result.filter((t) => checkTaskReady(t, tasks));\n  }\n\n  if (filter.offset && filter.offset > 0) {\n    result = result.slice(filter.offset);\n  }\n\n  if (filter.limit && filter.limit > 0) {\n    result = result.slice(0, filter.limit);\n  }\n\n  return result;\n}\n\n/**\n * Check if a task is ready (all dependencies resolved)\n */\nfunction checkTaskReady(task: TrackerTask, allTasks: TrackerTask[]): boolean {\n  if (!task.dependsOn || task.dependsOn.length === 0) {\n    return true;\n  }\n\n  return task.dependsOn.every((depId) => {\n    const depTask = allTasks.find((t) => t.id === depId);\n    return !depTask || depTask.status === 'completed' || depTask.status === 'cancelled';\n  });\n}\n\n/** Template cache */\nlet templateCache: string | null = null;\n\n/** Fallback template */\nconst FALLBACK_TEMPLATE = `{{#if prdContent}}\n## Project Context\n{{prdContent}}\n\n---\n{{/if}}\n\n## Task: {{taskId}}\n### {{taskTitle}}\n\n{{#if taskDescription}}\n## Description\n{{taskDescription}}\n{{/if}}\n\n{{#if acceptanceCriteria}}\n## Acceptance Criteria\n{{acceptanceCriteria}}\n{{/if}}\n\n{{#if dependsOn}}\n**Dependencies**: {{dependsOn}}\n{{/if}}\n\n{{#if recentProgress}}\n## Recent Progress\n{{recentProgress}}\n{{/if}}\n\n## Workflow\n1. Study the context above to understand the bigger picture\n2. Study \\`.ralph-tui/progress.md\\` for status, learnings, and patterns\n3. Implement this task following acceptance criteria\n4. Run quality checks: typecheck, lint, etc.\n5. Commit with: \\`feat: {{taskId}} - {{taskTitle}}\\`\n6. Document learnings in \\`.ralph-tui/progress.md\\`\n7. Signal completion with: <promise>COMPLETE</promise>\n\n## Stop Condition\n**IMPORTANT**: If the work is already complete, verify it meets acceptance criteria and signal completion immediately.\n`;\n\n// =============================================================================\n// Linear Tracker Plugin\n// =============================================================================\n\nexport class LinearTrackerPlugin implements TrackerPlugin {\n  readonly meta: TrackerPluginMeta = {\n    id: 'linear',\n    name: 'Linear Tracker',\n    description: 'Track tasks in Linear with two-way sync',\n    version: '1.0.0',\n    supportsBidirectionalSync: true,\n    supportsHierarchy: true,\n    supportsDependencies: true,\n  };\n\n  private client: LinearApiClient | null = null;\n  private config: Record<string, unknown> = {};\n  private ready = false;\n  private projectId: string = '';\n  private teamId: string = '';\n  private labelName: string = 'ralph-tui';\n  private userId: string = '';\n  private epicId: string = '';\n\n  // Cache\n  private taskCache: Map<string, TrackerTask> = new Map();\n  private stateCache: Map<string, LinearState[]> = new Map();\n  private lastSyncedTasks: Map<string, { task: TrackerTask; updatedAt: string }> = new Map();\n\n  async initialize(config: Record<string, unknown>): Promise<void> {\n    this.config = config;\n\n    // Get API key from config or environment\n    const apiKey = (config.apiKey as string) || process.env.LINEAR_API_KEY;\n    if (!apiKey) {\n      this.ready = false;\n      return;\n    }\n\n    this.client = new LinearApiClient(apiKey);\n\n    // Load configuration from config or environment\n    this.projectId = (config.projectId as string) || process.env.LINEAR_PROJECT_ID || '';\n    this.teamId = (config.teamId as string) || process.env.LINEAR_TEAM_ID || '';\n    this.labelName = (config.labelName as string) || process.env.LINEAR_LABEL_NAME || 'ralph-tui';\n\n    // Verify connection and get current user\n    try {\n      const viewer = await this.client.getViewer();\n      this.userId = viewer.id;\n      this.ready = true;\n    } catch (err) {\n      console.error('Failed to connect to Linear:', err);\n      this.ready = false;\n    }\n  }\n\n  async isReady(): Promise<boolean> {\n    if (!this.client) return false;\n\n    try {\n      await this.client.getViewer();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  getSetupQuestions(): SetupQuestion[] {\n    return [\n      {\n        id: 'apiKey',\n        prompt: 'Enter your Linear API key (or set LINEAR_API_KEY env var):',\n        type: 'password',\n        required: false,\n        help: 'Get your API key from https://linear.app/settings/api',\n      },\n      {\n        id: 'teamId',\n        prompt: 'Enter your Linear team ID:',\n        type: 'text',\n        required: true,\n        help: 'Run ralph-tui-linear-setup to get team/project IDs',\n      },\n      {\n        id: 'projectId',\n        prompt: 'Enter your Linear project ID:',\n        type: 'text',\n        required: true,\n        help: 'The project ID to track tasks from',\n      },\n      {\n        id: 'labelName',\n        prompt: 'Label name to filter tasks:',\n        type: 'text',\n        default: 'ralph-tui',\n        help: 'Tasks with this label will be tracked by ralph-tui',\n      },\n    ];\n  }\n\n  async validateSetup(answers: Record<string, unknown>): Promise<string | null> {\n    const apiKey = (answers.apiKey as string) || process.env.LINEAR_API_KEY;\n    if (!apiKey) {\n      return 'Linear API key is required (either in config or LINEAR_API_KEY environment variable)';\n    }\n\n    const testClient = new LinearApiClient(apiKey);\n    try {\n      await testClient.getViewer();\n      return null;\n    } catch (err) {\n      return `Failed to connect to Linear: ${err instanceof Error ? err.message : String(err)}`;\n    }\n  }\n\n  /**\n   * Get team workflow states (cached)\n   */\n  private async getTeamStates(): Promise<LinearState[]> {\n    if (!this.client || !this.teamId) return [];\n\n    if (this.stateCache.has(this.teamId)) {\n      return this.stateCache.get(this.teamId)!;\n    }\n\n    const states = await this.client.getStates(this.teamId);\n    this.stateCache.set(this.teamId, states);\n    return states;\n  }\n\n  /**\n   * Find state ID by type\n   */\n  private async findStateByType(targetType: LinearStateType): Promise<string | undefined> {\n    const states = await this.getTeamStates();\n    const state = states.find((s) => s.type === targetType);\n    return state?.id;\n  }\n\n  async getTasks(filter?: TaskFilter): Promise<TrackerTask[]> {\n    if (!this.client || !this.projectId) {\n      return [];\n    }\n\n    try {\n      const issues = await this.client.getIssuesByLabel(this.projectId, this.labelName);\n      const tasks = issues.map(issueToTask);\n\n      // Update cache\n      for (const task of tasks) {\n        this.taskCache.set(task.id, task);\n      }\n\n      return filterTasks(tasks, filter);\n    } catch (err) {\n      console.error('Failed to fetch tasks from Linear:', err);\n      return [];\n    }\n  }\n\n  async getTask(id: string): Promise<TrackerTask | undefined> {\n    if (this.taskCache.has(id)) {\n      return this.taskCache.get(id);\n    }\n\n    if (!this.client) return undefined;\n\n    try {\n      const issue = await this.client.getIssue(id);\n      const task = issueToTask(issue);\n      this.taskCache.set(id, task);\n      return task;\n    } catch {\n      return undefined;\n    }\n  }\n\n  async getNextTask(filter?: TaskFilter): Promise<TrackerTask | undefined> {\n    const tasks = await this.getTasks({\n      ...filter,\n      status: ['open', 'in_progress'],\n      ready: true,\n    });\n\n    if (tasks.length === 0) return undefined;\n\n    tasks.sort((a, b) => a.priority - b.priority);\n\n    const inProgress = tasks.find((t) => t.status === 'in_progress');\n    if (inProgress) return inProgress;\n\n    return tasks[0];\n  }\n\n  async completeTask(id: string, reason?: string): Promise<TaskCompletionResult> {\n    if (!this.client) {\n      return {\n        success: false,\n        message: 'Linear client not initialized',\n        error: 'Client not ready',\n      };\n    }\n\n    try {\n      const completedStateId = await this.findStateByType('completed');\n      if (!completedStateId) {\n        return {\n          success: false,\n          message: 'Could not find completed state',\n          error: 'No completed state found in team workflow',\n        };\n      }\n\n      const updatedIssue = await this.client.updateIssue(id, { stateId: completedStateId });\n\n      if (reason) {\n        await this.client.addComment(id, `Task completed by ralph-tui: ${reason}`);\n      }\n\n      const task = issueToTask(updatedIssue);\n      this.taskCache.set(id, task);\n\n      return {\n        success: true,\n        message: `Task ${updatedIssue.identifier} marked as complete`,\n        task,\n      };\n    } catch (err) {\n      return {\n        success: false,\n        message: `Failed to complete task ${id}`,\n        error: err instanceof Error ? err.message : String(err),\n      };\n    }\n  }\n\n  async updateTaskStatus(id: string, status: TrackerTaskStatus): Promise<TrackerTask | undefined> {\n    if (!this.client) return undefined;\n\n    try {\n      const targetStateType = mapStatusToStateType(status);\n      const stateId = await this.findStateByType(targetStateType);\n\n      if (!stateId) {\n        console.error(`Could not find state for type: ${targetStateType}`);\n        return undefined;\n      }\n\n      const updatedIssue = await this.client.updateIssue(id, { stateId });\n      const task = issueToTask(updatedIssue);\n      this.taskCache.set(id, task);\n\n      return task;\n    } catch (err) {\n      console.error(`Failed to update task ${id} status:`, err);\n      return undefined;\n    }\n  }\n\n  /**\n   * Claim a task - assign to current user and set to In Progress\n   */\n  async claimTask(id: string): Promise<TrackerTask | undefined> {\n    if (!this.client || !this.userId) return undefined;\n\n    try {\n      const inProgressStateId = await this.findStateByType('started');\n\n      const updatedIssue = await this.client.updateIssue(id, {\n        assigneeId: this.userId,\n        stateId: inProgressStateId,\n      });\n\n      const task = issueToTask(updatedIssue);\n      this.taskCache.set(id, task);\n\n      this.lastSyncedTasks.set(id, {\n        task,\n        updatedAt: updatedIssue.updatedAt,\n      });\n\n      return task;\n    } catch (err) {\n      console.error(`Failed to claim task ${id}:`, err);\n      return undefined;\n    }\n  }\n\n  async isComplete(filter?: TaskFilter): Promise<boolean> {\n    const tasks = await this.getTasks(filter);\n    return tasks.every((t) => t.status === 'completed' || t.status === 'cancelled');\n  }\n\n  async sync(): Promise<SyncResult> {\n    if (!this.client || !this.projectId) {\n      return {\n        success: false,\n        message: 'Linear client not initialized',\n        error: 'Client not ready',\n        syncedAt: new Date().toISOString(),\n      };\n    }\n\n    try {\n      const issues = await this.client.getIssuesByLabel(this.projectId, this.labelName);\n\n      let added = 0;\n      let updated = 0;\n\n      for (const issue of issues) {\n        const task = issueToTask(issue);\n        const cached = this.taskCache.get(task.id);\n\n        if (!cached) {\n          added++;\n        } else if (cached.updatedAt !== task.updatedAt) {\n          updated++;\n        }\n\n        this.taskCache.set(task.id, task);\n        this.lastSyncedTasks.set(task.id, {\n          task,\n          updatedAt: issue.updatedAt,\n        });\n      }\n\n      return {\n        success: true,\n        message: `Synced ${issues.length} tasks from Linear`,\n        added,\n        updated,\n        syncedAt: new Date().toISOString(),\n      };\n    } catch (err) {\n      return {\n        success: false,\n        message: 'Failed to sync with Linear',\n        error: err instanceof Error ? err.message : String(err),\n        syncedAt: new Date().toISOString(),\n      };\n    }\n  }\n\n  async isTaskReady(id: string): Promise<boolean> {\n    const task = await this.getTask(id);\n    if (!task) return false;\n\n    const allTasks = await this.getTasks();\n    return checkTaskReady(task, allTasks);\n  }\n\n  /**\n   * Detect conflicts between local and remote versions\n   */\n  async detectConflict(taskId: string): Promise<ConflictInfo | null> {\n    if (!this.client) return null;\n\n    const lastSynced = this.lastSyncedTasks.get(taskId);\n    if (!lastSynced) return null;\n\n    try {\n      const remoteIssue = await this.client.getIssue(taskId);\n      const remoteTask = issueToTask(remoteIssue);\n\n      if (remoteIssue.updatedAt !== lastSynced.updatedAt) {\n        const changedFields: string[] = [];\n\n        if (lastSynced.task.status !== remoteTask.status) changedFields.push('status');\n        if (lastSynced.task.title !== remoteTask.title) changedFields.push('title');\n        if (lastSynced.task.description !== remoteTask.description) changedFields.push('description');\n        if (lastSynced.task.assignee !== remoteTask.assignee) changedFields.push('assignee');\n\n        if (changedFields.length > 0) {\n          return {\n            taskId,\n            localVersion: lastSynced.task,\n            remoteVersion: remoteTask,\n            localUpdatedAt: lastSynced.updatedAt,\n            remoteUpdatedAt: remoteIssue.updatedAt,\n            changedFields,\n          };\n        }\n      }\n\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Resolve conflict by choosing a version\n   */\n  async resolveConflict(\n    taskId: string,\n    resolution: 'local' | 'remote' | 'merge'\n  ): Promise<TrackerTask | undefined> {\n    if (!this.client) return undefined;\n\n    const conflict = await this.detectConflict(taskId);\n    if (!conflict) {\n      return this.getTask(taskId);\n    }\n\n    if (resolution === 'remote') {\n      this.taskCache.set(taskId, conflict.remoteVersion);\n      this.lastSyncedTasks.set(taskId, {\n        task: conflict.remoteVersion,\n        updatedAt: conflict.remoteUpdatedAt,\n      });\n      return conflict.remoteVersion;\n    }\n\n    if (resolution === 'local') {\n      const stateType = mapStatusToStateType(conflict.localVersion.status);\n      const stateId = await this.findStateByType(stateType);\n\n      if (stateId) {\n        const updated = await this.client.updateIssue(taskId, {\n          stateId,\n          description: conflict.localVersion.description,\n        });\n        const task = issueToTask(updated);\n        this.taskCache.set(taskId, task);\n        this.lastSyncedTasks.set(taskId, {\n          task,\n          updatedAt: updated.updatedAt,\n        });\n        return task;\n      }\n    }\n\n    return conflict.remoteVersion;\n  }\n\n  async getEpics(): Promise<TrackerTask[]> {\n    if (!this.client || !this.projectId) {\n      return [];\n    }\n\n    try {\n      const epics = await this.client.getEpics(this.projectId);\n      return epics.map(issueToTask);\n    } catch (err) {\n      console.error('Failed to fetch epics from Linear:', err);\n      return [];\n    }\n  }\n\n  setEpicId(epicId: string): void {\n    this.epicId = epicId;\n  }\n\n  getEpicId(): string {\n    return this.epicId;\n  }\n\n  getTemplate(): string {\n    if (templateCache !== null) {\n      return templateCache;\n    }\n\n    const templatePath = join(__dirname, 'template.hbs');\n    try {\n      templateCache = readFileSync(templatePath, 'utf-8');\n      return templateCache;\n    } catch {\n      templateCache = FALLBACK_TEMPLATE;\n      return templateCache;\n    }\n  }\n\n  async getPrdContext(): Promise<{\n    name: string;\n    description?: string;\n    content: string;\n    completedCount: number;\n    totalCount: number;\n  } | null> {\n    if (!this.epicId || !this.client) {\n      return null;\n    }\n\n    try {\n      const epic = await this.client.getIssue(this.epicId);\n      const tasks = await this.getTasks({ parentId: this.epicId });\n\n      const completedCount = tasks.filter(\n        (t) => t.status === 'completed' || t.status === 'cancelled'\n      ).length;\n\n      return {\n        name: epic.title,\n        description: epic.description,\n        content: epic.description || '',\n        completedCount,\n        totalCount: tasks.length,\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  async dispose(): Promise<void> {\n    this.ready = false;\n    this.client = null;\n    this.taskCache.clear();\n    this.stateCache.clear();\n    this.lastSyncedTasks.clear();\n  }\n}\n\n/**\n * Factory function for the Linear tracker plugin\n */\nconst createLinearTracker: TrackerPluginFactory = () => new LinearTrackerPlugin();\n\nexport default createLinearTracker;\nexport { LinearApiClient } from './client.js';\nexport type { ConflictInfo } from './types.js';\n",
    "/**\n * ABOUTME: Linear API client for GraphQL queries and mutations.\n * Handles all communication with the Linear API.\n */\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Linear issue state types\n */\nexport type LinearStateType = 'backlog' | 'unstarted' | 'started' | 'completed' | 'canceled';\n\n/**\n * Linear issue from API\n */\nexport interface LinearIssue {\n  id: string;\n  identifier: string;\n  title: string;\n  description?: string;\n  priority: number; // 0 = no priority, 1 = urgent, 2 = high, 3 = normal, 4 = low\n  state: {\n    id: string;\n    name: string;\n    type: LinearStateType;\n  };\n  labels: {\n    nodes: Array<{ id: string; name: string }>;\n  };\n  assignee?: {\n    id: string;\n    name: string;\n    email: string;\n  };\n  parent?: {\n    id: string;\n    identifier: string;\n    title: string;\n  };\n  children?: {\n    nodes: LinearIssue[];\n  };\n  project?: {\n    id: string;\n    name: string;\n  };\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Linear team from API\n */\nexport interface LinearTeam {\n  id: string;\n  name: string;\n  key: string;\n  states: {\n    nodes: Array<{\n      id: string;\n      name: string;\n      type: LinearStateType;\n    }>;\n  };\n}\n\n/**\n * Linear user from API\n */\nexport interface LinearUser {\n  id: string;\n  name: string;\n  email: string;\n}\n\n/**\n * Linear workflow state\n */\nexport interface LinearState {\n  id: string;\n  name: string;\n  type: LinearStateType;\n}\n\n// =============================================================================\n// Linear API Client\n// =============================================================================\n\nexport class LinearApiClient {\n  private apiKey: string;\n  private baseUrl = 'https://api.linear.app/graphql';\n\n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n  }\n\n  /**\n   * Execute a GraphQL query against Linear API\n   */\n  async query<T>(query: string, variables?: Record<string, unknown>): Promise<T> {\n    const response = await fetch(this.baseUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': this.apiKey,\n      },\n      body: JSON.stringify({ query, variables }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Linear API error: ${response.status} ${response.statusText}`);\n    }\n\n    const result = await response.json() as { data?: T; errors?: Array<{ message: string }> };\n\n    if (result.errors && result.errors.length > 0) {\n      throw new Error(`Linear GraphQL error: ${result.errors[0].message}`);\n    }\n\n    return result.data as T;\n  }\n\n  /**\n   * Get current user\n   */\n  async getViewer(): Promise<LinearUser> {\n    const data = await this.query<{ viewer: LinearUser }>(`\n      query {\n        viewer {\n          id\n          name\n          email\n        }\n      }\n    `);\n    return data.viewer;\n  }\n\n  /**\n   * Get team by ID or key\n   */\n  async getTeam(teamId: string): Promise<LinearTeam> {\n    const data = await this.query<{ team: LinearTeam }>(`\n      query($id: String!) {\n        team(id: $id) {\n          id\n          name\n          key\n          states {\n            nodes {\n              id\n              name\n              type\n            }\n          }\n        }\n      }\n    `, { id: teamId });\n    return data.team;\n  }\n\n  /**\n   * Get issues with a specific label from a project\n   */\n  async getIssuesByLabel(\n    projectId: string,\n    labelName: string = 'ralph-tui'\n  ): Promise<LinearIssue[]> {\n    const data = await this.query<{ issues: { nodes: LinearIssue[] } }>(`\n      query($projectId: ID!, $labelName: String!) {\n        issues(\n          filter: {\n            project: { id: { eq: $projectId } }\n            labels: { name: { eq: $labelName } }\n          }\n          first: 100\n        ) {\n          nodes {\n            id\n            identifier\n            title\n            description\n            priority\n            state {\n              id\n              name\n              type\n            }\n            labels {\n              nodes {\n                id\n                name\n              }\n            }\n            assignee {\n              id\n              name\n              email\n            }\n            parent {\n              id\n              identifier\n              title\n            }\n            children {\n              nodes {\n                id\n                identifier\n                title\n                state {\n                  id\n                  name\n                  type\n                }\n              }\n            }\n            project {\n              id\n              name\n            }\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    `, { projectId, labelName });\n    return data.issues.nodes;\n  }\n\n  /**\n   * Get a single issue by ID\n   */\n  async getIssue(issueId: string): Promise<LinearIssue> {\n    const data = await this.query<{ issue: LinearIssue }>(`\n      query($id: String!) {\n        issue(id: $id) {\n          id\n          identifier\n          title\n          description\n          priority\n          state {\n            id\n            name\n            type\n          }\n          labels {\n            nodes {\n              id\n              name\n            }\n          }\n          assignee {\n            id\n            name\n            email\n          }\n          parent {\n            id\n            identifier\n            title\n          }\n          children {\n            nodes {\n              id\n              identifier\n              title\n              state {\n                id\n                name\n                type\n              }\n            }\n          }\n          project {\n            id\n            name\n          }\n          createdAt\n          updatedAt\n        }\n      }\n    `, { id: issueId });\n    return data.issue;\n  }\n\n  /**\n   * Update an issue (state, assignee, labels)\n   */\n  async updateIssue(\n    issueId: string,\n    input: {\n      stateId?: string;\n      assigneeId?: string;\n      labelIds?: string[];\n      description?: string;\n    }\n  ): Promise<LinearIssue> {\n    const data = await this.query<{ issueUpdate: { success: boolean; issue: LinearIssue } }>(`\n      mutation($id: String!, $input: IssueUpdateInput!) {\n        issueUpdate(id: $id, input: $input) {\n          success\n          issue {\n            id\n            identifier\n            title\n            description\n            priority\n            state {\n              id\n              name\n              type\n            }\n            labels {\n              nodes {\n                id\n                name\n              }\n            }\n            assignee {\n              id\n              name\n              email\n            }\n            updatedAt\n          }\n        }\n      }\n    `, { id: issueId, input });\n\n    if (!data.issueUpdate.success) {\n      throw new Error('Failed to update issue');\n    }\n\n    return data.issueUpdate.issue;\n  }\n\n  /**\n   * Add a comment to an issue\n   */\n  async addComment(issueId: string, body: string): Promise<void> {\n    await this.query<{ commentCreate: { success: boolean } }>(`\n      mutation($issueId: String!, $body: String!) {\n        commentCreate(input: { issueId: $issueId, body: $body }) {\n          success\n        }\n      }\n    `, { issueId, body });\n  }\n\n  /**\n   * Get workflow states for a team\n   */\n  async getStates(teamId: string): Promise<LinearState[]> {\n    const team = await this.getTeam(teamId);\n    return team.states.nodes;\n  }\n\n  /**\n   * Get epics (issues with type=epic label or parent issues)\n   */\n  async getEpics(projectId: string): Promise<LinearIssue[]> {\n    const data = await this.query<{ issues: { nodes: LinearIssue[] } }>(`\n      query($projectId: ID!) {\n        issues(\n          filter: {\n            project: { id: { eq: $projectId } }\n            labels: { name: { in: [\"epic\", \"Epic\"] } }\n          }\n          first: 50\n        ) {\n          nodes {\n            id\n            identifier\n            title\n            description\n            priority\n            state {\n              id\n              name\n              type\n            }\n            labels {\n              nodes {\n                id\n                name\n              }\n            }\n            children {\n              nodes {\n                id\n                identifier\n                title\n                state {\n                  id\n                  name\n                  type\n                }\n              }\n            }\n            project {\n              id\n              name\n            }\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    `, { projectId });\n\n    return data.issues.nodes;\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "ECFF3E4EB51F375D64756E2164756E21",
  "names": []
}